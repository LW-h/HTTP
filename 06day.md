## HTTP首部

> HTTP协议的请求和响应报文中必定包含HTTP首部。因HTTP版本或扩展规范的变化，首部字段可支持的字段内容略有不同。

#### HTTP首部字段

> 使用首部字段是为了给浏览器或服务器提供报文主体大小、所使用的语言、认证信息...HTTP首部字段是由首部字段名和首部字段值构成，中间用‘：’分隔。例如：首部字段名：字段值

> 当HTTP报文首部字段名出现相同时，在规范中尚未明确，浏览器的逻辑处理可能不一样。有些浏览器会优先处理第一次出现的字段，有些浏览器会优先处理最后出现的首部字段。

HTTP四种类型字段：

+ 通用首部字段(General Header Fields):请求和响应报文中都会使用的字段
+ 请求首部字段(Request Header Fields)：从客户端向服务器发送请求报文时使用的首部，补充了请求的附加内容、客户端信息、响应内容相关优先级...
+ 响应首部字段(Response Header Fields):从服务器向客户端返回响应报文时使用的首部，补充了响应的附加内容、也会要求客户端附加额外的内容信息
+ 实体首部字段(Entity Header Fields):针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间等与实体有关的信息。

非HTTP/1.1首部字段

> 在HTTP协议通信交互中使用到的首部字段，不限于RFC2616定义的47中首部字段。还有Cookie、Set-Cookie、Content-Disposition等在其它RFC中定义的首部字段。这些非正式的首部字段统一归纳在RFC4299 HTTP Header Field Registrations中

HTTP首部字段将定义成缓存代理和非缓存代理行为

+ 端到端首部(End-to-end Header):分在此类别中的首部会转发给请求/响应对应的最终接收目标，而且必须保存在由缓存生成的响应中，另外规定它必须被转发
+ 逐跳首部(Hop-by-hop Header)；分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1和之后的版本，如果要使用hop-by-hop首部，需提供Connection首部字段。

###### 通用首部字段

+ Cache-Control:通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制 
  + public:表明其它用户也可以利用的缓存
  + private:缓存服务器会对该特定用户提供资源缓存的服务，对于其它用户发送过来的请求，代理服务器不会返回缓存
  + no-cache:目的是为了防止从缓存中返回过期的资源。客户端包含此命令，表示客户端不会接收缓存过的响应，中间缓存服务器就会把请求转发到源服务器。如果该字段在服务器端，那么源服务器不会对资源进行缓存，且禁止对响应资源进行缓存。
  + no-store：暗示请求/响应中包含了机密信息。no-cashe表示不缓存过期的资源，no-store表示不进行缓存。
  + s-maxage:s-maxage与max-age指令功能相同，不同点是s-maxage指令只适用于供多位用户使用的公共缓存服务器。当客户端包含这个字段时，如果判定缓存资源的缓存时间小于指定时间，那么客户端就接收缓存的资源，当指定为max-age=0时，那么缓存服务器通常会将请求转发给源服务器。当服务端包含max-age指令时，缓存服务器将不对资源的有效性再作确认，而max-age数值代表资源保存为缓存的最长世时间
  + min-fresh:要求缓存服务器返回至少还未过指定时间的缓存资源。
  + max-stale:指示缓存资源，即使过期也照常接收
  + only-if-cached:表示客户端仅在缓存服务器本地缓存目录资源的情况下才会要求返回。缓存服务器不重新加载响应，也不会再次去确认资源的有效性。若发生请求缓存服务器的本地无响应，则返回504 Gateway Timeout
  + must-revalidate:代理会向源服务器再次去验证即将返回的响应缓存目前是否有效。若源服务器无响应，则返回504 Gateway Timeout，会忽略掉max-stale
  + proxy-revalidate:要求所有的缓存服务器在接受到客户端的请求时，必须再次验证缓存的有效性
  + no-transform:无论时请求还是响应，缓存都不能改变缓存实体主体的媒体类型。可以防止缓存或代理压缩图片...

+ Connection:

> 有两个作用：控制不再转发给代理的首部字段；管理持久连接.HTTP/1.1版本的默认连接都是持久连接，为此，客户端会在持久连接的状态下连续发送请求，当服务端想断开连接时，则指明Connection 字段的值为Close。相反HTTP/1.1之前的连接为非持久性连接，通信双方会在Connection字段中加入Keep-alive值

+ Date
> 表明创建HTTP报文的日期和时间

+ Pragma

> 是HTTP/1.1之前版本的字段，仅作为与HTTP/1.0的向后兼容而定义。该字段为通用字段，但是只用在客户端发送的请求中，客户端要求中间服务器不返回缓存的资源。所有的中间服务器如果都能以HTTP/1.1为基准，直接采用Cache-Control:no-cache最为理想。但要求掌握全部的中间HTTP服务器是不太理想的。因此同时包含如下两个字段是比较理想的：Cache-Control:no-cache;Pragma:no-cache

+ Trailer

> 此字段会事先说明在报文主体之后记录了哪些首部字段，该字段可应用在HTTP/1.1版本分块传输时。

+ Transfer-Encoding

> 规定传输报文主体采用的编码方式，HTTP/1.1的传输方式仅对分块传输编码有效

+ Upgrad

> 用于检测HTTP协议及其其它协议是否可使用更高的版本进行通信。参数可以用来指定一个完全不同的通信协议。

+ Via

> 为了追踪客户端与服务端之间的请求和响应报文的传输路径。Via不仅用于追踪报文的转发，还可以避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。Via首部是为了追踪传输路径，所以经常会和TRACE一起使用。例如：代理服务器接收到由TRACE方法发送过来的请求(其中Max-Forwards为0)时，代理服务器就不能转发请求信息，代理服务器会将自己的信息附加到Via首部后，返回该请求的响应。

+ Warning 

> HTTP/1.1的Warning首部是从HTTP/1.0的响应首部(Retry-After)演变过来的。该首部通常会告知用户一些与缓存相关的问题警告。格式如下：**Warning:[警告码][警告的主机：端口号]‘[警告内容]’([日期时间])**。例如：Warning 113 gw.hackr.jp:8080 'Heuristic expiration' Tue, 05。HTTP/1.1中定义了7种警告如下：

+ 七种警告
  + 警告码【110】；警告内容【Response is stale，响应已过期】；说明：代理返回已经过期的内容
  + 警告码【111】；警告内容【Revalidation failed,再验证失败】；说明：代理再验证资源有效性时失败(服务器无法到达等原因)
  + 警告码【112】；警告内容【Disconnection operation,断开连接操作】；说明：代理与互联网连接故意切断
  + 警告码【113】；警告内容【Heuristic expiration,试探性过期】；说明：响应的试用期超过24小时(响应的试用期超过24小时【有效缓存的设定时间大于24小时的情况下】)
  + 警告码【199】；警告内容【Miscellaneous warning,杂项警告】；说明：任意的警告内容
  + 警告码【214】；警告内容【Transformation applied,使用了转换】；说明：代理对内容编码或媒体类型等执行了某些处理时
  + 警告码【299】；警告内容【Miscellaneous persistent warning,持久杂项警告】；说明：任意的警告内容

###### 请求首部字段

> 请求首部字段是从客户端往服务器端发送请求报文中使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容

+ Accept:可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用type/subtype这种形式，一次可以指定多种类型。
  + 文本文件：
      + text/html,text/plain,text/css...
      + application/xhtml+xml,application/xml...
  + 图片文件：
      + image/jpeg,image/gif,image/png...
  + 视频文件：
      + video/mpeg,video/quicktime...
  + 应用程序使用的二进制文件：
      + application/octet-stream,application/zip...

> 给媒体增加优先级，则使用q=来额外表示权重值1，用分号进行分隔。权重值q的范围是0~1(可精确到小数点后3位)，且1为最大值。不指定权重q值时，默认权重为q=1.0.当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。

+ Accept-Charset:可以用来通知服务器用户代理支持的字符集及字符集向对应的优先级。可以一次性指定多种优先级，与首部字段Accept相同的是可用权重q值来表示相对优先级。例如：**Accept-Charset:ios-8859-5,unicode-1-1;q-0.8**
+ Accept-Encoding:用来告知代理服务器支持的内容编码及内容编码的优先级。可以一次性指定多种内容编码。
+ Accept-Language:用来告知服务器代理能够处理的自然语言集，以及自然语言集的相对优先级，可一次指定多种优先级
+ Authorization:首部字段Authorization是用来告知服务器，用户代理的认证信息(证书值)。通常，想要通过服务器认证的用户代理会在接收到返回的401状态码响应后，把首部字段Authorization加入请求中，共用缓存在接收到含有Authorization请求时，操作处理会有所不同。
+ Expect:期望服务端出现某种特定的行为，因服务器无法理解客户端的期望作出的回应而发出的错误时，会返回状态码417Expectation Failed。客户端可以利用首部字段，写明期望的扩展
+ From:告知服务器使用用户代理的用户的电子邮件地址。目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。可能因为代理的不同，将电子邮件记录在User-Agent首部字段中。
+ Host:虚拟主机运行在同一个IP上，因此需要HOST加以区分。会告知服务端，请求的资源所处的互联网主机名和端口号。Host首部字段是在HTTP/1.1中唯一一个必须包含的请求的首部字段。
+ **If-Match**:形如If-xxx这种样式的请求首部字段，都可称为条件请求。服务器在接收到附带条件的请求时，只有判断条件为真时，才会执行请求。服务端会对比If-Match的字段值和资源的T=ETag值，仅当两者一致，才会执行请求。反之会返回状态码412 Precondition Failed的响应。还可以使用*指定If-Match的字段值。针对这个值，服务端会忽略掉，只要资源存在就会执行。
+ If-Modified-Since:如果在If-Modified-Since字段指定日期时间后，资源发生了更新，服务器会接收请求。会告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望能处理该请求。而在指定If-Modified-Since字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码304 Not Modified的响应
+ **If-None-Match**:只有在If-None-Match的字段值与ETag值不一致时，可处理该请求。与If-Match相反。首部字段If-None-Match属于附带条件之一。用于指定If-None-Match字段值的实体标记(ETag)值与请求资源ETag不一致时，他就告知服务器处理该请求。在GET、HEAD方法中使用首部字段If-None-Match可获取最新的资源。这与使用首部字段If-Modified-Since时有些类似。
+ If-Range:首部字段If-Range属于附带条件之一，会告知服务器若指定的If-Range字段值(ETag值或者时间)和请求资源的ETag值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。如果服务器的资源更新，那客户端持有资源的一部分就会随之无效，当然，范围请求作为前提时无效的。这时，服务器会暂时以状态码412Precondition Failed作为响应返回，其目的是催客户端再次发送请求，这样一来，与使用If-Range比起来，就需要花费两倍时间。
+ If-Unmodified-Since:该字段与If-Unmodified-Since的作用相反，会告知服务器端，指定请求资源只有在字段值内指定的日期时间之后。未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码412 Precondition Failed作为响应返回
+ Max-Forwards:每次转发数值减1，当数值为0时返回响应。可以在TRACE或OPTIONS方法中加入此字段，以十进制标识最大可经过的服务器数目。
+ Proxy-Authorization:接收到从代理服务器发过来的认证质询时，客户端会发送包含字段Proxy-Authrization的请求，告知服务器需要的信息。这个行为与客户端和服务器之间的HTTP访问认证相类似。该字段发生在客户端与代理之间。客户端与服务端之间的认证使用Authorization 
+ Range:告知服务器获取资源的指定范围，处理请求之后会返回状态码206 Partial Content的响应。无法处理时，则会返回状态码200 OK响应及其全部资源
+ Referer:首部字段Referer会告知服务器请求的原始资源的URI。因为原始资源的URI可能包含有ID或密码等信息，出于安全考虑，可以不发送该字段。Referer的正确拼写应该是Referrer.但现今仍然使用错误的拼写单词
+ TE:会告知服务端客户端支持的处理响应的传输编码及相对优先级。和首部字段Accept-Encoding相似，但是用于传输编码。还可以指定伴随trailer字段的分块传输编码的方式，只需要把trailers赋值给该字段值
+ User-Agent：会将创建请求的浏览器和用户代理名称等信息传达给服务器。由网络爬虫发起的请求，可能在其中添加爬虫作者的电子邮件地址，如果经过代理，中间可能添加代理服务器的名称

###### 响应首部字段

> 用于补充响应的附加信息、服务器信息，以及对客户端的附加要求

+ Accept-Ranges:用来告知客户端服务器是否能够处理范围请求，以指定获取服务器端的某个资源。该字段有两中值，可处理范围请求时指定为bytes,反之为none
+ Age:可以告知客户端，源服务器在多久前创建了响应，单位为秒。若创建响应的是缓存服务器，Age是缓存后的响应再次发起认证到认证完成的时间值，代理创建响应时必须加上Age
+ ETag:能告知实体标识，它是一种可将资源以字符串形式唯一表示的方式，服务器会为每一个资源分配对应的ETag，当资源发生更新时，ETag也会随之变化。所有仅凭URI指定缓存的资源是相当困难的，若在下载过程中出现连接中断，再连接的情况，都会依照ETag值来指定资源。
  + 强ETag值：不论实体发生多么细微的变化都会改变其值
  + 弱ETag值：只用来提示资源是否相同。只有资源发生根本改变，产生差异时才会改变ETag,这是会在字段值最开始处附加W/
  + Location:可以将响应接收方引导至某个与请求URI位置不同的资源。该字段会配合3XX，Redirection的响应，提供重定向的URI，几乎所有的浏览器在接收到包含有Location的响应后，都会强制尝试对重定向资源的访问
  + Proxy-Authenticate:会把代理服务器所要求的认证信息发送给客户端
  + Retry-After:会告知客户端在多久之后再次发送请求，主要配合状态码503 Service Unavailable响应，或3XX Redirect响应一起使用
  + Server:会告知客户端服务器上安装的HTTP服务器应用程序信息，还可能包含版本号...
  + Vary:当接收到带有Vary首部字段指定获取资源的请求时，如果使用的Accept-Language字段的值相同，那么就直接从缓存返回响应，反之，则需要从源端获取资源
  + WWW-Authenticate:会告知客户端适用于访问请求URI所指定资源的认证方案(Basic、Digest)和带参数提示的质询(Challenge).状态码401是可定带有此首部字段

###### 实体首部字段

> 包含在请求和响应报文的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息

+ Allow:通知客户端能够支持Request-URI指定资源的所有HTTP方法，当服务器收到不支持的HTTP方法时，会返回405 Method Not Allowed响应，与此同时，还会把支持的方法返回。
+ Content-Encoding:会告知客户端服务器对实体的主体部分选用的内容编码方式，内容编码是指在不丢失实体信息的前提下进行的压缩
+ Content-Language:会告知客户端实体使用的自然语言集
+ Content-Length:表明实体大小，单位为字节，当对实体进行编码后，不能再使用此首部字段。
+ Content-Location:会告知主体部分对应的URI，
+ Content-MD5:完整性校验
+ Content-Range:针对范围请求，返回使用的首部字段，
+ Content-Type:说明实体主体内对象的媒体类型，和首部字段Accept一样
+ Epires:会将资源失效的日期告知客户端
+ Last-Modified:指明资源最终修改的时间

###### 为Cookie服务的首部字段

> Cookie是管理服务器与客户端之间的状态，Cookie的工作机制是用户识别及状态管理。Web网站为了管理用户的状态会通过浏览器，把一些数据临时写入用户的计算机内。接着当用户访问Web网站时，可通过通信方式取回之前发送的Cookie.至2013年5月，Cookie的规格文档有以下4种：

+ RFC2109:某企业尝试独立技术对Cookie规格进行标准化，原本意图与网景公司合作，但后来发生了变化，现在该标准已经淡出人们的视线
+ RFC2965：为终结微软浏览器与网景公司浏览器的标准差异而导致的浏览器战争，RFC2965定义了新的HTTP首部Set-Cookie2和Cookie2.但事实上并没有怎么投入
+ RFC6265：将网景公司指定的标准作为业界事实标准，重新定义Cookie标准后的产物目前使用广泛的Cookie技术并不是在RFC规范的文档，而是在网景公司的标准下进行的扩展
+ Set-Cookie:当服务器准备开始管理客户端的状态时，会事先告知各种信息。字段值如下：
  + name-value:Cookie名称和值
  + expires:指定浏览器可发送Cookie的有效期。当省略掉其有效期仅限于维持浏览器会话(Session)时间段内。这通常限于浏览器应用程序被关闭之前
  + path:可以限制指定Cookie的发送范围的文件目录。不过有办法避开这项限制，安全机制不能包有期望
  + domain:通过指定的域名可做到与结尾匹配一致。例如：指定example.com后，除example.com以外，www2.example.com也可以发送Cookie.因此，除了针对具体指定的多个域名发送Cookie之外，不指定domain属性显得更安全
  + secure:限制Web页面仅在HTTPS安全连接时，才可以发送Cookie，当省略时，不论时HTTP或HTTPS，都会对Cookie进行回收
  + HttpOnly:是Cookie的扩展功能，它使得JavaScript脚本无法获得Cookie.目的就是防止跨站脚本攻击对Cookie的信息窃取。该扩展并非是为了防止XSS而开发
  + Cookie:当用户想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。接收多个Cookie时，同样可以以多个Cookie形式发送

###### 其它首部字段

> HTTP首部字段是可以自行扩展的，所以在Web服务器和浏览器的应用上，会出现各种非标准的首部字段

  + X-Frame-Options:属于响应首部，用于控制网站内容在其它Web网站的Frame标签内的显示问题。主要是为了防止点击劫持攻击。有两个可指定的字段值如下：
    + DENY:拒绝，
    + SAMEORIGIN:仅同源域名下的页面匹配时许可。
    + X-XSS-Protection:属于HTTP响应首部，是针对跨站脚本攻击的一种对策。指定的值如下：
      + 0：将XSS过滤设置成无效状态
      + 1：将XSS过滤设置为有效状态
    + DNT:属于HTTP首部字段，是Do Not Track的简写，意为拒绝个人信息被收集。0：同意被追踪，1：拒绝被追踪
    + P3P：属于响应首部，通过技术(The Platform for Privacy Preferences,在线隐私偏好平台)技术，可以让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的[P3P](http://www.w3.org/TR/P3P).协议中对X-前缀的废除，在HTTP等多种协议中，通过给非标准参数加上前缀X-来区别于标准参数，并使那些非标准的参数作为扩展变成可能。但是这种简单除暴的做法不是很好。在RFC6648中提议停止。然而对已经改变的，不要求其变更