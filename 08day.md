## 确认访问用户身份的认证

> 某些Web页面只想让特定的人浏览，或者干脆仅本人可见。为达到这个目的，必不可少的就是认证功能

核对登录者信息通常是指以下这些：

+ 密码：只有本人才会知道的字符串信息
+ 动态令牌：仅限本人持有的设备内显示的一次性密码
+ 数字证书：仅限本人(终端)持有的信息
+ 生物认证：指纹和虹膜等本人的生理信息
+ IC卡等：仅限本人持有的信息

> HTTP/1.1使用的认证方式如下：

+ BASIC认证(基本认证)
+ DIGEST认证(摘要认证)
+ SSL(客户端认证)
+ FormBase认证(基于表单认证)
+ 此外还有Windows统一认证(Keberos认证、NTLM认证)

###### BASIC认证

> 当请求的资源需要BASIC认证时，服务器会随状态码401 Authrization Required,返回带WWW-Authentication首部字段的响应。该字段内包含认证方式(BASIC)及Request-URI安全域字符串(realm)。客户端需要将用户ID及密码发送给服务器。发送的内容是由用户ID和密码构成。中间由冒号分隔，再经过Base64编码处理。例如：**假设客户端ID为guest密码为guest,连接起来会形成guest:guest这样的字符串，然后经过Base64编码，最后结果变成：Z3Vlc3Q6Z3VIc3Q=,把此字符串写入首部字段Authorization后发出请求**。当用户代理为浏览器时，用户仅输入ID和密码，之后浏览器会自动完成Base64编码的转换工作

> 如果验证成功，则会返回一条包含Request-URI资源的响应。Base认证缺点：**不是加密处理，容易被盗取。想再进行一次BASIC认证时，一般的浏览器却无法实现认证注销操作**BASIC认证使用上不够灵活，且达不到多数Web网站期望的安全等级，所以不常使用

###### DIGEST认证

> 为弥补BASIC认证存在的弱点，从HTTP/1.1起就有了DIGEST认证。DIGEST认证同样使用质询/响应的方式(challenge/response),但不像BASIC明文发送

> 请求需认证的资源时，服务器会随着状态码401 Authorization Required,返回带WWW-Authenticate首部字段的响应，该字段包括质询响应方式认证所需的临时质询码(随机数，nonce),首部字段必须包含realm和nonce这两个字段的信息。客户端就是依靠这两个值进行认证的。nonce是一种每次返回的401响应生成的任意随机数字符串。该字符串通常推荐使用Base64十六进制，但实际依赖服务器的实际情况

> 客户端在接收到认证信息时，会返回包含Authorization字段信息。首部字段Authorization必须包含username、realm、nonce、uri和response字段信息。其中，realm和nonce就是之前服务器接收到的响应字段。

+  username是realm限定范围内进行认证的用户名
+  uri(digest-uri)即Request-URI的值，考虑到经过代理转发后其值可能被修改，因此事先会复制一份副本保存在uri内
+  response即是Request-Digest,存放经过MD5运算后的密码字符串，形成响应码

> 认证成功后，返回信息中会包含首部字段Authentication-Info写入一些认证成功的相关信息。缺点：**认证安全虽有进步，但和HTTPS相比较仍然很弱，DIGEST认证提供密码保护机制，但并不存在用户伪装的保护机制，DIGEST认证和BASIC认证一样，使用不够灵活，达不到安全标准**

###### SSL客户端认证

> 传统使用ID和密码认证的方式只要内容正确，就可认证是本人的行为。但如果被盗，就有可能被冒充，利用SSL就可以避免这种情况。SSL认证是借由HTTPS的客户端证书完成认证的方式

> 为到达客户端认证的目的，需要事先将客户端的证书分发给客户端，且客户端必须安装。认证步骤如下：

+ 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求提供证书
+ 客户端选择需要发送的证书，以报文的方式发送给服务器
+ 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信

###### SSL客户端认证采双因素认证

> 多数情况下，SSL客户端认证不会依靠证书完成认证，一般都会结合表单组合成双因素认证(Two-factor-authentication)来使用。简言之，第一个认证因素的SSL客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是客户本人操作

###### 表单验证

> 基于表单的认证方法并不是在HTTP协议中定义的，客户端会向服务器上的Web应用程序发送登录信息，按登录信息来验证

###### Session管理及Cookie应用

> 基于表单验证的标准尚未规定，一般会使用Cookie来管理Session会话。基于表单认证本身是通过服务器的Web应用，将客户端发送过来的用户ID和密码与之前登录过的信息来进行匹配。鉴于HTTP是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来，因此，即使当该用户下一次继续访问，也无法区分该用户与其它用户。Session管理及Cookie状态管理步骤如下：

+ 客户端把用户ID和密码等信息放入报文的实体部分，通常以POST方法把请求发送给服务器。会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送
+ 服务器会发放用以识别用户的Session ID,通过验证从客户端发送过来的登录信息进行身份认证。然后把用户的认证状态与Session ID绑定后记录在服务器端。向客户端返回响应，会在首部字段Set-Cookie内写入Session ID。安全方面：**如果Session ID被第三方盗走，对方可以伪装身份进行恶意操作，因此必须防止Session ID被盗。因此Session ID因该以难以推测的字符串，而且服务器也需要进行有效期的管理，加上httponly属性**
+ 客户端会以Cookie方式保存在本地，下次向服务器发送请求时，会自动携带Cookie一起发送。

> 服务端保存用户提交的密码登录信息，一种安全的保存方法是，先利用给密码加盐(salt)的方式增加额外信息，再使用散列(hash)函数计算出散列值后保存。salt就是由服务器随机生成的一个字符串，但是要保证足够长，并且是随机生成的。然后把它和密码拼接生成散列值。当两个用户使用同一个密码时，由于随机生成的salt值不同，对应的散列值也就不同。这样很大程度减少了密码特征，这样攻击者很难利用自己手中的密码特征库进行破解